"""
Test the Qt test infrastructure to ensure proper qtbot and QApplication management.

This test verifies that our Qt fixtures work correctly and prevent common
Qt testing issues like multiple QApplication instances and resource leaks.
"""

import pytest
from unittest.mock import Mock

# Test markers for Qt infrastructure validation
pytest_plugins = ["pytestqt"]

# Qt infrastructure tests must run serially to avoid QApplication conflicts
pytestmark = [
    pytest.mark.serial,
    pytest.mark.qt_application,
    pytest.mark.qt_app
]


@pytest.mark.qt_app
def test_qapplication_singleton(qapp_session):
    """Verify single QApplication instance across test session."""
    try:
        from PyQt6.QtWidgets import QApplication
        
        # Get instances multiple times
        app1 = QApplication.instance()
        app2 = QApplication.instance()
        
        # Should be the same instance
        assert app1 is app2
        assert app1 is not None
        
        # Should match our fixture
        assert app1 is qapp_session
        
    except ImportError:
        # In environments without Qt, should get mock
        assert isinstance(qapp_session, Mock)


def test_qtbot_widget_cleanup(qtbot):
    """Verify widgets are properly registered with qtbot for cleanup."""
    try:
        from PyQt6.QtWidgets import QWidget, QLabel, QVBoxLayout
        
        # Create a test widget
        widget = QWidget()
        qtbot.addWidget(widget)
        
        # Add some content
        label = QLabel("Test content")
        layout = QVBoxLayout()
        layout.addWidget(label)
        widget.setLayout(layout)
        
        # Widget should be registered with qtbot
        # qtbot will handle cleanup automatically
        assert widget is not None
        assert label.text() == "Test content"
        
    except ImportError:
        # In headless environments, qtbot might be mocked
        assert hasattr(qtbot, 'addWidget')
        qtbot.addWidget(Mock())


@pytest.mark.gui
def test_qt_gui_functionality(qtbot):
    """Test that requires full Qt GUI capabilities."""
    try:
        from PyQt6.QtWidgets import QWidget, QPushButton
        from PyQt6.QtCore import QTimer, pyqtSignal
        
        class TestWidget(QWidget):
            clicked = pyqtSignal()
            
            def __init__(self):
                super().__init__()
                self.button = QPushButton("Test Button")
                self.button.clicked.connect(self.clicked.emit)
        
        widget = TestWidget()
        qtbot.addWidget(widget)
        
        # Test signal emission
        with qtbot.waitSignal(widget.clicked, timeout=1000):
            widget.button.click()
            
    except ImportError:
        # In mock environments, just verify mock functionality
        assert hasattr(qtbot, 'waitSignal')
        assert hasattr(qtbot, 'addWidget')


def test_safe_qtbot_fallback(safe_qtbot):
    """Test that safe_qtbot provides proper fallback in headless environments."""
    # Should always have required methods
    assert hasattr(safe_qtbot, 'addWidget')
    assert hasattr(safe_qtbot, 'waitSignal')
    assert hasattr(safe_qtbot, 'wait')
    assert hasattr(safe_qtbot, 'mouseClick')
    assert hasattr(safe_qtbot, 'keyClick')
    
    # Should be callable without errors
    safe_qtbot.addWidget(Mock())
    safe_qtbot.wait(1)


def test_safe_qapp_functionality(safe_qapp):
    """Test that safe_qapp provides necessary QApplication functionality."""
    # Should always have processEvents method
    assert hasattr(safe_qapp, 'processEvents')
    
    # Should be callable without errors
    safe_qapp.processEvents()


@pytest.mark.no_gui
def test_no_gui_marker():
    """Test that doesn't require Qt GUI components."""
    # This test should run in all environments
    assert True


def test_qt_cleanup_integration(qtbot, qapp_session):
    """Test that Qt cleanup works properly between tests."""
    try:
        from PyQt6.QtWidgets import QWidget
        import gc
        
        # Create widgets that will be cleaned up
        widgets = [QWidget() for _ in range(5)]
        for widget in widgets:
            qtbot.addWidget(widget)
        
        # Force garbage collection
        gc.collect()
        
        # Process events to allow cleanup
        if hasattr(qapp_session, 'processEvents'):
            qapp_session.processEvents()
            
    except ImportError:
        # In mock environments, just verify structure
        pass


def test_thread_safety_marker():
    """Test Qt thread safety markers work correctly."""
    import threading
    
    # Should be running in main thread for Qt operations
    assert threading.current_thread() is threading.main_thread()


@pytest.mark.mock_gui
def test_mock_gui_in_headless():
    """Test that mock_gui marker allows GUI tests in headless mode."""
    # This test should run even in headless environments
    # because it uses mocks instead of real Qt widgets
    from unittest.mock import Mock
    
    mock_widget = Mock()
    mock_widget.show = Mock()
    mock_widget.close = Mock()
    
    # Mock GUI operations
    mock_widget.show()
    mock_widget.close()
    
    assert mock_widget.show.called
    assert mock_widget.close.called


def test_qt_markers_configuration():
    """Test that Qt-specific pytest markers are properly configured."""
    import pytest
    
    # Verify our custom markers are available
    # This helps ensure the pytest configuration is working
    marker_names = {
        'qt_app',
        'gui', 
        'mock_gui',
        'no_gui',
        'thread_safety'
    }
    
    # At least some of our markers should be recognized
    # (exact verification depends on pytest internals)
    assert len(marker_names) > 0


@pytest.mark.stability
def test_multiple_qapplication_prevention():
    """Test that we prevent multiple QApplication instances."""
    try:
        from PyQt6.QtWidgets import QApplication
        
        # Get the current instance
        app1 = QApplication.instance()
        
        # Attempting to create another should return the same instance
        # (QApplication constructor will raise an error if we try to create another)
        app2 = QApplication.instance()
        
        assert app1 is app2
        
    except ImportError:
        # In mock environments, this is handled by our fixture
        pass


def test_qt_resource_cleanup():
    """Test that Qt resources are properly cleaned up."""
    import gc
    
    # Force garbage collection
    gc.collect()
    
    # Check active thread count (should be reasonable)
    import threading
    active_count = threading.active_count()
    
    # Should not have excessive threads
    # Allow some tolerance for background threads
    assert active_count < 10, f"Too many active threads: {active_count}"