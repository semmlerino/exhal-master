"""Integration tests adapted for headless environments"""

import sys
from pathlib import Path
from unittest.mock import MagicMock, Mock, patch

import pytest
from PIL import Image

# Add parent directories to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from core.extractor import SpriteExtractor
from core.palette_manager import PaletteManager
from core.workers import VRAMExtractionWorker
from utils.constants import (
    BYTES_PER_TILE,
    COLORS_PER_PALETTE,
    SPRITE_PALETTE_END,
    SPRITE_PALETTE_START,
    VRAM_SPRITE_OFFSET,
)


class TestVRAMExtractionWorkerHeadless:
    """Test VRAMExtractionWorker in headless environment"""

# Serial execution required: Thread safety concerns
pytestmark = [
    
    pytest.mark.serial,
    pytest.mark.thread_safety
]


    @pytest.fixture
    def mock_qt_imports(self):
        """Mock Qt imports for headless testing"""
        # Mock PyQt6 modules
        mock_qobject = MagicMock()
        mock_qthread = MagicMock()
        mock_signal = MagicMock()
        mock_qpixmap = MagicMock()

        # Make signals callable
        mock_signal.return_value = MagicMock()

        with patch.dict(
            "sys.modules",
            {
                "PyQt6.QtCore": MagicMock(
                    QObject=mock_qobject, QThread=mock_qthread, pyqtSignal=mock_signal
                ),
                "PyQt6.QtGui": MagicMock(QPixmap=mock_qpixmap),
            },
        ):
            yield {
                "QObject": mock_qobject,
                "QThread": mock_qthread,
                "pyqtSignal": mock_signal,
                "QPixmap": mock_qpixmap,
            }

    @pytest.fixture
    def worker_params(self, tmp_path):
        """Create parameters for VRAMExtractionWorker"""
        # Create minimal test files
        vram_data = bytearray(0x10000)
        # Add test tiles
        for i in range(5):
            for j in range(32):
                vram_data[VRAM_SPRITE_OFFSET + i * 32 + j] = (i * 32 + j) % 256

        cgram_data = bytearray(512)
        # Add test colors
        for i in range(256, 512, 2):
            cgram_data[i] = 0x1F
            cgram_data[i + 1] = 0x00

        vram_path = tmp_path / "test.vram"
        cgram_path = tmp_path / "test.cgram"

        vram_path.write_bytes(vram_data)
        cgram_path.write_bytes(cgram_data)

        return {
            "vram_path": str(vram_path),
            "cgram_path": str(cgram_path),
            "output_base": str(tmp_path / "output"),
            "create_grayscale": True,
            "create_metadata": False,
            "oam_path": None,
        }

    def test_worker_logic_without_qt(self, worker_params, mock_qt_imports):
        """Test worker logic without Qt dependencies"""
        # Initialize managers for this test
        from core.managers import cleanup_managers, initialize_managers
        initialize_managers("TestApp")

        try:
            # Mock the extraction manager before creating worker
            with patch("core.workers.extraction.get_extraction_manager") as mock_get_manager:
                # Create mock manager
                mock_manager = Mock()
                mock_get_manager.return_value = mock_manager

                # Create worker with mocked manager
                worker = VRAMExtractionWorker(worker_params)

                # Create test image
                Image.new("P", (128, 64), 0)

                # Mock manager signals to return Mock connections
                mock_connection = Mock()

                mock_manager.extraction_progress = Mock()
                mock_manager.extraction_progress.connect = Mock(return_value=mock_connection)
                mock_manager.palettes_extracted = Mock()
                mock_manager.palettes_extracted.connect = Mock(return_value=mock_connection)
                mock_manager.active_palettes_found = Mock()
                mock_manager.active_palettes_found.connect = Mock(return_value=mock_connection)
                mock_manager.preview_generated = Mock()
                mock_manager.preview_generated.connect = Mock(return_value=mock_connection)

                # Mock the extraction result
                output_path = worker_params["output_base"] + ".png"
                mock_manager.extract_from_vram.return_value = [output_path]

                # Create proper mocks for signals
                progress_mock = Mock()
                progress_mock.emit = Mock()
                preview_mock = Mock()
                preview_mock.emit = Mock()
                preview_image_mock = Mock()
                preview_image_mock.emit = Mock()
                palettes_mock = Mock()
                palettes_mock.emit = Mock()
                active_palettes_mock = Mock()
                active_palettes_mock.emit = Mock()
                finished_mock = Mock()
                finished_mock.emit = Mock()
                error_mock = Mock()
                error_mock.emit = Mock()

                # Replace signals
                worker.progress = progress_mock
                worker.preview_ready = preview_mock
                worker.preview_image_ready = preview_image_mock
                worker.palettes_ready = palettes_mock
                worker.active_palettes_ready = active_palettes_mock
                worker.extraction_finished = finished_mock
                worker.error = error_mock

                # Mock pixmap creation to avoid Qt dependency
                with patch("core.controller.pil_to_qpixmap") as mock_pil_to_qpixmap, \
                     patch.object(worker, "disconnect_manager_signals") as mock_disconnect:
                    mock_pil_to_qpixmap.return_value = Mock()
                    mock_disconnect.return_value = None

                    # Run the worker logic directly (not as thread)
                    worker.run()

                # Check if error was emitted
                if error_mock.emit.called:
                    error_msg = error_mock.emit.call_args[0][0]
                    print(f"Error emitted: {error_msg}")

                # Verify the key behaviors:
                # 1. Manager was called to extract from VRAM
                assert mock_manager.extract_from_vram.called
                call_kwargs = mock_manager.extract_from_vram.call_args[1]
                assert call_kwargs["vram_path"] == worker_params["vram_path"]
                assert call_kwargs["output_base"] == worker_params["output_base"]

                # 2. Finished signal was emitted with the files
                assert finished_mock.emit.called
                assert finished_mock.emit.call_args[0][0] == [output_path]

                # 3. No error was emitted
                assert not error_mock.emit.called
        finally:
            # Clean up managers
            cleanup_managers()

    def test_worker_error_handling_headless(self, mock_qt_imports):
        """Test error handling without Qt"""
        # Initialize managers for this test
        from core.managers import cleanup_managers, initialize_managers
        initialize_managers("TestApp")

        try:
            bad_params = {
                "vram_path": "/nonexistent/file.vram",
                "cgram_path": "/nonexistent/file.cgram",
                "output_base": "/invalid/output",
                "create_grayscale": True,
                "create_metadata": False,
                "oam_path": None,
            }

            worker = VRAMExtractionWorker(bad_params)

            # Mock signals
            worker.error = Mock()
            worker.progress = Mock()
            worker.preview_ready = Mock()
            worker.preview_image_ready = Mock()
            worker.palettes_ready = Mock()
            worker.active_palettes_ready = Mock()
            worker.finished = Mock()

            # Mock pil_to_qpixmap to avoid Qt dependency
            with patch("core.controller.pil_to_qpixmap") as mock_pil_to_qpixmap:
                mock_pil_to_qpixmap.return_value = Mock()

                # Run worker
                worker.run()

            # Should emit error
            assert worker.error.emit.called
            error_msg = worker.error.emit.call_args[0][0]
            assert any(phrase in error_msg.lower() for phrase in ["no such file", "not found", "does not exist", "vram file"])
            assert not worker.finished.emit.called
        finally:
            # Clean up managers
            cleanup_managers()


class TestWorkerBusinessLogic:
    """Test worker business logic extracted from Qt dependencies"""

    def test_extraction_workflow_logic(self, tmp_path):
        """Test the extraction workflow without threading"""
        # Create test files
        vram_data = bytearray(0x10000)
        cgram_data = bytearray(512)

        # Add sprite data
        for i in range(10):
            tile_offset = VRAM_SPRITE_OFFSET + i * BYTES_PER_TILE
            for j in range(BYTES_PER_TILE):
                vram_data[tile_offset + j] = (i + j) % 256

        # Add palette data
        for pal_idx in range(SPRITE_PALETTE_START, SPRITE_PALETTE_END):
            for color_idx in range(COLORS_PER_PALETTE):
                offset = (pal_idx * COLORS_PER_PALETTE + color_idx) * 2
                # Simple color pattern
                color = ((pal_idx << 10) | (color_idx << 5) | color_idx) & 0x7FFF
                cgram_data[offset] = color & 0xFF
                cgram_data[offset + 1] = (color >> 8) & 0xFF

        vram_path = tmp_path / "test.vram"
        cgram_path = tmp_path / "test.cgram"
        output_base = tmp_path / "output"

        vram_path.write_bytes(vram_data)
        cgram_path.write_bytes(cgram_data)

        # Simulate worker workflow
        extractor = SpriteExtractor()
        palette_manager = PaletteManager()

        # Extract sprites
        output_file = f"{output_base}.png"
        img, num_tiles = extractor.extract_sprites_grayscale(
            str(vram_path), output_file
        )

        assert Path(output_file).exists()
        # Default extraction uses VRAM_SPRITE_SIZE (0x4000 bytes = 512 tiles)
        assert num_tiles == 512

        # Extract palettes
        palette_manager.load_cgram(str(cgram_path))
        sprite_palettes = palette_manager.get_sprite_palettes()
        assert len(sprite_palettes) == 8

        # Create palette files
        main_pal_file = f"{output_base}.pal.json"
        palette_manager.create_palette_json(8, main_pal_file, output_file)
        assert Path(main_pal_file).exists()

        # Create individual palette files
        for pal_idx in range(SPRITE_PALETTE_START, SPRITE_PALETTE_END):
            pal_file = f"{output_base}_pal{pal_idx}.pal.json"
            palette_manager.create_palette_json(pal_idx, pal_file, output_file)
            assert Path(pal_file).exists()

    def test_pixmap_creation_mocked(self, tmp_path):
        """Test pixmap creation can be mocked for headless"""
        # Create a test image
        test_img = Image.new("P", (128, 128), 0)

        # Mock QPixmap in the correct location (image_utils.py)
        with patch("utils.image_utils.QPixmap") as mock_pixmap_class:
            mock_pixmap = Mock()
            mock_pixmap.loadFromData.return_value = True
            mock_pixmap_class.return_value = mock_pixmap

            # Import and test the pil_to_qpixmap function
            from core.controller import pil_to_qpixmap

            # Test pixmap creation
            result = pil_to_qpixmap(test_img)

            # Verify mock was used
            assert mock_pixmap.loadFromData.called
            assert result == mock_pixmap
