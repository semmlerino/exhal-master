"""
Registry for accessing manager instances
"""

import threading
import weakref
from typing import Any

from PyQt6.QtWidgets import QApplication

from utils.logging_config import get_logger
from utils.safe_logging import (
    safe_debug,
    safe_info,
    safe_warning,
    suppress_logging_errors,
)

from .exceptions import ManagerError
from .extraction_manager import ExtractionManager
from .injection_manager import InjectionManager
from .session_manager import SessionManager

# NavigationManager import deferred to avoid circular imports


class ManagerRegistry:
    """Singleton registry for manager instances with memory leak prevention"""

    _instance: "ManagerRegistry | None" = None
    _lock: threading.Lock = threading.Lock()
    _cleanup_registered: bool = False

    def __new__(cls) -> "ManagerRegistry":
        """Ensure only one instance exists"""
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self) -> None:
        """Initialize the registry"""
        # Only initialize once
        if hasattr(self, "_initialized"):
            return

        self._logger = get_logger("ManagerRegistry")
        self._managers: dict[str, Any] = {}
        self._manager_refs: dict[str, weakref.ReferenceType] = {}  # Weak references for cleanup
        self._initialized = True

        # Register cleanup with QApplication if available
        self._register_cleanup_hooks()

        self._logger.info("ManagerRegistry initialized")

    def _register_cleanup_hooks(self) -> None:
        """Register cleanup hooks with Qt application"""
        if not ManagerRegistry._cleanup_registered:
            try:
                app = QApplication.instance()
                if app is not None:
                    app.aboutToQuit.connect(lambda: self.cleanup_managers())
                    ManagerRegistry._cleanup_registered = True
                    self._logger.debug("Registered cleanup with QApplication.aboutToQuit")
            except Exception as e:
                self._logger.debug(f"Could not register Qt cleanup: {e}")

    def _on_manager_deleted(self, manager_name: str) -> None:
        """Callback when a manager is deleted via weak reference"""
        self._logger.debug(f"Manager '{manager_name}' was garbage collected")
        # Remove from managers dict if still present
        if manager_name in self._managers:
            del self._managers[manager_name]

    def initialize_managers(self, app_name: str = "SpritePal", settings_path: Any = None) -> None:
        """
        Initialize all managers with proper error handling and cleanup

        Args:
            app_name: Application name for settings
            settings_path: Optional custom settings path (for testing)

        Raises:
            ManagerError: If manager initialization fails
        """
        with self._lock:  # Ensure thread-safe initialization
            # Skip if already initialized
            if self.is_initialized():
                self._logger.debug("Managers already initialized, skipping")
                return

            self._logger.info("Initializing managers...")

            # Get Qt application instance for proper parent management
            app = QApplication.instance()
            if not app:
                self._logger.warning("No QApplication instance found - managers will have no Qt parent")
                qt_parent = None
            else:
                qt_parent = app
                self._logger.debug("Using QApplication as Qt parent for managers")

            # Track which managers were created for cleanup on failure
            created_managers = []

            try:
                # Initialize session manager first as others may depend on it
                # SessionManager inherits from BaseManager (QObject), so it can take a parent
                self._logger.debug("Creating SessionManager...")
                session_manager = SessionManager(app_name, settings_path)
                session_manager.setParent(qt_parent)  # Set parent after creation
                self._managers["session"] = session_manager
                self._manager_refs["session"] = weakref.ref(session_manager,
                    lambda ref: self._on_manager_deleted("session"))
                created_managers.append("session")
                self._logger.debug("SessionManager created successfully")

                # Initialize Qt-based managers with proper parent to prevent lifecycle issues
                self._logger.debug("Creating ExtractionManager...")
                extraction_manager = ExtractionManager(parent=qt_parent)
                self._managers["extraction"] = extraction_manager
                self._manager_refs["extraction"] = weakref.ref(extraction_manager,
                    lambda ref: self._on_manager_deleted("extraction"))
                created_managers.append("extraction")
                self._logger.debug("ExtractionManager created successfully")

                self._logger.debug("Creating InjectionManager...")
                injection_manager = InjectionManager(parent=qt_parent)
                self._managers["injection"] = injection_manager
                self._manager_refs["injection"] = weakref.ref(injection_manager,
                    lambda ref: self._on_manager_deleted("injection"))
                created_managers.append("injection")
                self._logger.debug("InjectionManager created successfully")

                # TODO: NavigationManager disabled due to threading issues in tests
                # self._logger.debug("Creating NavigationManager...")
                # from core.navigation.manager import NavigationManager
                # self._managers["navigation"] = NavigationManager(parent=qt_parent)
                # created_managers.append("navigation")
                # self._logger.debug("NavigationManager created successfully")

                # Future managers will be added here

                self._logger.info("All managers initialized successfully")

            except Exception as e:
                self._logger.exception(f"Manager initialization failed: {e}")

                # Cleanup any managers that were created before the failure
                for manager_name in created_managers:
                    try:
                        if manager_name in self._managers:
                            manager = self._managers[manager_name]
                            manager.cleanup()
                            del self._managers[manager_name]
                            # Clean up weak reference
                            self._manager_refs.pop(manager_name, None)
                            self._logger.debug(f"Cleaned up {manager_name} manager after initialization failure")
                    except Exception as cleanup_error:
                        self._logger.exception(f"Error cleaning up {manager_name} manager: {cleanup_error}")

                # Re-raise as ManagerError
                raise ManagerError(f"Failed to initialize managers: {e}") from e

    @suppress_logging_errors
    def cleanup_managers(self) -> None:
        """Cleanup all managers with enhanced memory leak prevention"""
        safe_info(self._logger, "Cleaning up managers...")

        # Cleanup in reverse order
        for name in reversed(list(self._managers.keys())):
            try:
                manager = self._managers[name]
                manager.cleanup()
                safe_debug(self._logger, f"Cleaned up {name} manager")
            except (AttributeError, RuntimeError):
                safe_warning(self._logger, f"Error cleaning up {name} manager", exc_info=True)
            except Exception:
                safe_warning(self._logger, f"Error cleaning up {name} manager", exc_info=True)

        self._managers.clear()
        self._manager_refs.clear()  # Clear weak references

        # Clear context references to break circular dependencies
        try:
            from .context import _context_manager
            if _context_manager is not None:
                _context_manager.set_current_context(None)
                safe_debug(self._logger, "Cleared context manager references")
            else:
                safe_debug(self._logger, "Context manager already cleaned up")
        except Exception as e:
            safe_debug(self._logger, f"Error clearing context references: {e}")

        safe_info(self._logger, "All managers cleaned up")

    def get_session_manager(self) -> SessionManager:
        """
        Get the session manager instance

        Returns:
            SessionManager instance

        Raises:
            ManagerError: If manager not initialized
        """
        return self._get_manager("session", SessionManager)

    def get_extraction_manager(self) -> ExtractionManager:
        """
        Get the extraction manager instance

        Returns:
            ExtractionManager instance

        Raises:
            ManagerError: If manager not initialized
        """
        return self._get_manager("extraction", ExtractionManager)

    def get_injection_manager(self) -> InjectionManager:
        """
        Get the injection manager instance

        Returns:
            InjectionManager instance

        Raises:
            ManagerError: If manager not initialized
        """
        return self._get_manager("injection", InjectionManager)

    def get_navigation_manager(self):
        """
        Get the navigation manager instance

        Returns:
            NavigationManager instance

        Raises:
            ManagerError: If manager not initialized
        """
        # TODO: NavigationManager disabled due to threading issues in tests
        raise ManagerError("NavigationManager temporarily disabled for test stability")

    def _get_manager(self, name: str, expected_type: type) -> Any:
        """
        Get a manager by name with type checking and dependency validation

        Args:
            name: Manager name
            expected_type: Expected manager type

        Returns:
            Manager instance

        Raises:
            ManagerError: If manager not found, wrong type, or not properly initialized
        """
        if name not in self._managers:
            raise ManagerError(
                f"{name.capitalize()} manager not initialized. "
                "Call initialize_managers() first."
            )

        manager = self._managers[name]
        if not isinstance(manager, expected_type):
            raise ManagerError(
                f"Manager type mismatch: expected {expected_type.__name__}, "
                f"got {type(manager).__name__}"
            )

        # Validate that the manager is properly initialized
        if not manager.is_initialized():
            raise ManagerError(
                f"{name.capitalize()} manager found but not properly initialized. "
                "This may indicate a partial initialization failure."
            )

        return manager

    def is_initialized(self) -> bool:
        """Check if managers are initialized"""
        # Check that all expected managers are present
        # Note: NavigationManager is currently disabled due to threading issues in tests
        expected_managers = {"session", "extraction", "injection"}
        return expected_managers.issubset(self._managers.keys())

    def get_all_managers(self) -> dict[str, Any]:
        """Get all registered managers (for testing/debugging)"""
        return self._managers.copy()

    def validate_manager_dependencies(self) -> bool:
        """
        Validate that all managers and their dependencies are properly initialized

        Returns:
            True if all dependencies are satisfied, False otherwise

        Raises:
            ManagerError: If critical dependency issues are found
        """
        if not self.is_initialized():
            self._logger.warning("Managers not initialized, cannot validate dependencies")
            return False

        self._logger.debug("Validating manager dependencies...")

        try:
            # Validate that all managers are individually initialized
            for name, manager in self._managers.items():
                if not manager.is_initialized():
                    raise ManagerError(f"{name} manager not properly initialized")

            # Validate specific dependency relationships
            # InjectionManager depends on SessionManager
            injection_manager = self._managers.get("injection")
            session_manager = self._managers.get("session")

            if injection_manager and not session_manager:
                raise ManagerError("InjectionManager requires SessionManager but it's not available")

            self._logger.debug("All manager dependencies validated successfully")
            return True

        except Exception as e:
            self._logger.exception(f"Manager dependency validation failed: {e}")
            return False


# Global instance accessor functions with context support
_registry = ManagerRegistry()

# Register cleanup at module level to prevent memory leaks
@suppress_logging_errors
def _cleanup_global_registry():
    """Cleanup function for module-level registry"""
    global _registry
    if _registry is not None:
        try:
            _registry.cleanup_managers()
        except Exception:
            pass  # Ignore errors during cleanup
        _registry = None

import atexit

atexit.register(_cleanup_global_registry)


def get_registry() -> ManagerRegistry:
    """Get the global manager registry instance"""
    return _registry


def get_session_manager() -> SessionManager:
    """
    Get the session manager instance.

    Checks current context first, then falls back to global registry.

    Returns:
        SessionManager instance

    Raises:
        ManagerError: If managers not initialized
    """
    # Check if we have a current context with this manager
    from .context import get_current_context

    context = get_current_context()
    if context and context.has_manager("session"):
        return context.get_manager("session", SessionManager)

    # Fallback to global registry
    return _registry.get_session_manager()


def get_extraction_manager() -> ExtractionManager:
    """
    Get the extraction manager instance.

    Checks current context first, then falls back to global registry.

    Returns:
        ExtractionManager instance

    Raises:
        ManagerError: If managers not initialized
    """
    # Check if we have a current context with this manager
    from .context import get_current_context

    context = get_current_context()
    if context and context.has_manager("extraction"):
        return context.get_manager("extraction", ExtractionManager)

    # Fallback to global registry
    return _registry.get_extraction_manager()


def get_injection_manager() -> InjectionManager:
    """
    Get the injection manager instance.

    Checks current context first, then falls back to global registry.

    Returns:
        InjectionManager instance

    Raises:
        ManagerError: If managers not initialized
    """
    # Check if we have a current context with this manager
    from .context import get_current_context

    context = get_current_context()
    if context and context.has_manager("injection"):
        return context.get_manager("injection", InjectionManager)

    # Fallback to global registry
    return _registry.get_injection_manager()


def get_navigation_manager():
    """
    Get the global navigation manager instance

    Returns:
        NavigationManager instance

    Raises:
        ManagerError: If managers not initialized
    """
    return _registry.get_navigation_manager()


def initialize_managers(app_name: str = "SpritePal", settings_path: Any = None) -> None:
    """
    Initialize all managers

    Args:
        app_name: Application name for settings
        settings_path: Optional custom settings path (for testing)
    """
    _registry.initialize_managers(app_name, settings_path)


def cleanup_managers() -> None:
    """Cleanup all managers"""
    _registry.cleanup_managers()


def are_managers_initialized() -> bool:
    """Check if managers are initialized"""
    return _registry.is_initialized()


def validate_manager_dependencies() -> bool:
    """
    Validate that all manager dependencies are satisfied

    Returns:
        True if all dependencies are valid, False otherwise
    """
    return _registry.validate_manager_dependencies()
