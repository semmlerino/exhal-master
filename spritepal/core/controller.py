"""
Main controller for SpritePal extraction workflow
"""

from __future__ import annotations

import subprocess
import sys
from pathlib import Path
from typing import TYPE_CHECKING, Any, NotRequired, Protocol, TypedDict, cast

from PIL import Image
from PySide6.QtCore import QObject
from PySide6.QtWidgets import QWidget

if TYPE_CHECKING:
    from core.protocols.manager_protocols import (
        ExtractionManagerProtocol,
        InjectionManagerProtocol,
        MainWindowProtocol,
        SessionManagerProtocol,
    )

from core.console_error_handler import ConsoleErrorHandler
from core.managers import (
    ExtractionManager,
    InjectionManager,
    get_extraction_manager,
    get_injection_manager,
    get_session_manager,
)
from core.workers import ROMExtractionWorker, VRAMExtractionWorker
from ui.common import WorkerManager
from ui.common.error_handler import get_error_handler
from ui.grid_arrangement_dialog import GridArrangementDialog
from ui.injection_dialog import InjectionDialog
from ui.row_arrangement_dialog import RowArrangementDialog
from utils.constants import (
    DEFAULT_TILES_PER_ROW,
    TILE_WIDTH,
    VRAM_SPRITE_OFFSET,
)
from utils.file_validator import FileValidator
from utils.image_utils import pil_to_qpixmap
from utils.logging_config import get_logger
from utils.preview_generator import create_vram_preview_request, get_preview_generator
from utils.settings_manager import get_settings_manager


# Type definitions
class ExtractionParams(TypedDict):
    """Type definition for extraction parameters"""
    vram_path: str
    cgram_path: str
    oam_path: str
    vram_offset: int
    output_base: str
    create_grayscale: bool
    create_metadata: bool
    grayscale_mode: bool

class ROMExtractionParams(TypedDict):
    """Type definition for ROM extraction parameters"""
    rom_path: str
    sprite_offset: int
    sprite_name: str
    output_base: str
    cgram_path: NotRequired[str | None]

logger = get_logger(__name__)

class ErrorHandlerProtocol(Protocol):
    """Protocol defining the error handler interface for type safety"""

    def handle_exception(self, exception: Exception, context: str = "") -> None:
        """Handle an exception with optional context"""
        ...

    def handle_critical_error(self, title: str, message: str) -> None:
        """Handle a critical error"""
        ...

    def handle_warning(self, title: str, message: str) -> None:
        """Handle a warning"""
        ...

    def handle_info(self, title: str, message: str) -> None:
        """Handle an info message"""
        ...

    def handle_validation_error(
        self,
        error: Exception,
        context_info: str,
        user_input: str | None = None,
        **context_kwargs: Any
    ) -> Any:
        """Handle a validation error with context"""
        ...

# MockErrorHandler removed - replaced with ConsoleErrorHandler
# The MockErrorHandler was a dangerous pattern that silently swallowed errors.
# Now using ConsoleErrorHandler which properly logs errors to console/file.

class ExtractionController(QObject):
    """Controller for the extraction workflow"""

    def __init__(
        self,
        main_window: MainWindowProtocol,
        extraction_manager: ExtractionManagerProtocol | None = None,
        session_manager: SessionManagerProtocol | None = None,
        injection_manager: InjectionManagerProtocol | None = None,
    ) -> None:
        super().__init__()
        self.main_window: MainWindowProtocol = main_window

        # Use injected managers or fall back to global registry for backward compatibility
        # Keep union types for maximum flexibility while ensuring we have the required interface
        self.session_manager = session_manager or get_session_manager()
        self.extraction_manager = extraction_manager or get_extraction_manager()
        self.injection_manager = injection_manager or get_injection_manager()

        # Workers still managed locally (thin wrappers)
        self.worker: VRAMExtractionWorker | None = None
        self.rom_worker: ROMExtractionWorker | None = None

        # Initialize error handler with fallback to console handler
        try:
            # Check if main_window is a QWidget for error handler compatibility
            if isinstance(self.main_window, QWidget):
                self.error_handler = get_error_handler(self.main_window)
            else:
                # Use console error handler for non-QWidget protocols (e.g., in tests)
                logger.debug("MainWindowProtocol is not a QWidget, using console error handler")
                self.error_handler = ConsoleErrorHandler()
        except (TypeError, AttributeError):
            # Fallback to console error handler for test scenarios or when UI is unavailable
            # This ensures errors are properly logged instead of being silently ignored
            logger.warning("UI error handler unavailable, using console error handler")
            self.error_handler = ConsoleErrorHandler()

        # Connect UI signals
        _ = self.main_window.extract_requested.connect(self.start_extraction)
        _ = self.main_window.open_in_editor_requested.connect(self.open_in_editor)
        _ = self.main_window.arrange_rows_requested.connect(self.open_row_arrangement)
        _ = self.main_window.arrange_grid_requested.connect(self.open_grid_arrangement)
        _ = self.main_window.inject_requested.connect(self.start_injection)
        _ = self.main_window.extraction_panel.offset_changed.connect(
            self.update_preview_with_offset
        )

        # Connect injection manager signals (cast to concrete type for signal access)
        injection_mgr = cast(InjectionManager, self.injection_manager)
        _ = injection_mgr.injection_progress.connect(self._on_injection_progress)
        _ = injection_mgr.injection_finished.connect(self._on_injection_finished)
        _ = injection_mgr.cache_saved.connect(self._on_cache_saved)

        # Connect extraction manager cache signals (cast to concrete type for signal access)
        extraction_mgr = cast(ExtractionManager, self.extraction_manager)
        _ = extraction_mgr.cache_operation_started.connect(self._on_cache_operation_started)
        _ = extraction_mgr.cache_hit.connect(self._on_cache_hit)
        _ = extraction_mgr.cache_miss.connect(self._on_cache_miss)
        _ = extraction_mgr.cache_saved.connect(self._on_cache_saved)

        # Initialize preview generator with managers
        self.preview_generator = get_preview_generator()
        # Cast to concrete type for preview generator compatibility
        extraction_mgr = cast(ExtractionManager, self.extraction_manager)
        self.preview_generator.set_managers(
            extraction_manager=extraction_mgr,
            rom_extractor=extraction_mgr.get_rom_extractor()
        )

    def start_extraction(self) -> None:
        """Start the extraction process"""
        # Get parameters from UI
        params = self.main_window.get_extraction_params()

        # PARAMETER VALIDATION: Check requirements first for better UX
        # Users should get helpful parameter guidance before file system errors
        try:
            # TypedDict is compatible with dict[str, Any] for validation
            self.extraction_manager.validate_extraction_params(params)
        except Exception as e:
            self.main_window.extraction_failed(str(e))
            return

        # DEFENSIVE VALIDATION: Only validate files that exist to prevent blocking I/O
        # This ensures fail-fast behavior before expensive worker thread operations
        vram_path = params.get("vram_path", "")

        # CRITICAL FIX FOR BUG #11: Add file format validation to prevent 2+ minute blocking
        # Only validate VRAM file if it was provided (already checked by parameter validation)
        if vram_path:
            vram_result = FileValidator.validate_vram_file(vram_path)
            if not vram_result.is_valid:
                self.main_window.extraction_failed(vram_result.error_message or "VRAM file validation failed")
                return

            # Show warnings if any
            for warning in vram_result.warnings:
                logger.warning(f"VRAM file warning: {warning}")

        cgram_path = params.get("cgram_path", "")
        if cgram_path:  # Only validate if CGRAM path was provided
            cgram_result = FileValidator.validate_cgram_file(cgram_path)
            if not cgram_result.is_valid:
                self.main_window.extraction_failed(cgram_result.error_message or "CGRAM file validation failed")
                return

            # Show warnings if any
            for warning in cgram_result.warnings:
                logger.warning(f"CGRAM file warning: {warning}")

        oam_path = params.get("oam_path", "")
        if oam_path:
            oam_result = FileValidator.validate_oam_file(oam_path)
            if not oam_result.is_valid:
                self.main_window.extraction_failed(oam_result.error_message or "OAM file validation failed")
                return

            # Show warnings if any
            for warning in oam_result.warnings:
                logger.warning(f"OAM file warning: {warning}")

        # Create and start worker thread
        # Import VRAMExtractionParams from the worker module
        from core.workers.extraction import VRAMExtractionParams

        # Convert validated params dict to VRAMExtractionParams TypedDict
        extraction_params: VRAMExtractionParams = {
            "vram_path": params["vram_path"],
            "cgram_path": params.get("cgram_path") or None,
            "oam_path": params.get("oam_path") or None,
            "vram_offset": params.get("vram_offset", VRAM_SPRITE_OFFSET),
            "output_base": params["output_base"],
            "create_grayscale": params.get("create_grayscale", True),
            "create_metadata": params.get("create_metadata", True),
            "grayscale_mode": params.get("grayscale_mode", False),
        }
        self.worker = VRAMExtractionWorker(extraction_params)
        _ = self.worker.progress.connect(self._on_progress)
        _ = self.worker.preview_ready.connect(self._on_preview_ready)
        _ = self.worker.preview_image_ready.connect(self._on_preview_image_ready)
        _ = self.worker.palettes_ready.connect(self._on_palettes_ready)
        _ = self.worker.active_palettes_ready.connect(self._on_active_palettes_ready)
        _ = self.worker.extraction_finished.connect(self._on_extraction_finished)
        _ = self.worker.error.connect(self._on_extraction_error)
        self.worker.start()

    def _on_progress(self, percent: int, message: str) -> None:
        """Handle progress updates"""
        self.main_window.status_bar.showMessage(message)

    def _on_preview_ready(self, pil_image: Image.Image, tile_count: int) -> None:
        """Handle preview ready - convert PIL Image to QPixmap in main thread"""
        # CRITICAL FIX FOR BUG #26: Convert PIL Image to QPixmap in main thread (safe!)
        # Worker now emits PIL Image to avoid Qt threading violations
        pixmap = pil_to_qpixmap(pil_image)
        if pixmap is not None:
            self.main_window.sprite_preview.set_preview(pixmap, tile_count)
            self.main_window.preview_coordinator.update_preview_info(f"Tiles: {tile_count}")
        else:
            logger.error("Failed to convert PIL image to QPixmap for preview")

    def _on_preview_image_ready(self, pil_image: Image.Image) -> None:
        """Handle preview PIL image ready"""
        self.main_window.sprite_preview.set_grayscale_image(pil_image)

    def _on_palettes_ready(self, palettes: dict[str, list[tuple[int, int, int]]]) -> None:
        """Handle palettes ready"""
        self.main_window.palette_preview.set_all_palettes(palettes)
        self.main_window.sprite_preview.set_palettes(palettes)

    def _on_active_palettes_ready(self, active_palettes: list[int]) -> None:
        """Handle active palettes ready"""
        self.main_window.palette_preview.highlight_active_palettes(active_palettes)

    def _on_extraction_finished(self, extracted_files: list[str]) -> None:
        """Handle extraction finished"""
        self.main_window.extraction_complete(extracted_files)
        self._cleanup_worker()

    def _on_extraction_error(self, error_message: str, exception: Exception | None = None) -> None:
        """Handle extraction error"""
        self.main_window.extraction_failed(error_message)
        self._cleanup_worker()

    def _cleanup_worker(self) -> None:
        """Safely cleanup worker thread"""
        WorkerManager.cleanup_worker(self.worker, timeout=3000)
        self.worker = None

    def update_preview_with_offset(self, offset: int) -> None:
        """Update preview with new VRAM offset without full extraction"""
        logger.debug(f"Updating preview with offset: 0x{offset:04X} ({offset})")

        try:
            # Check if we have VRAM loaded
            has_vram = self.main_window.extraction_panel.has_vram()
            logger.debug(f"Has VRAM loaded: {has_vram}")

            if not has_vram:
                logger.debug("No VRAM loaded, skipping preview update")
                return

            # Get VRAM path
            logger.debug("Getting VRAM path from extraction panel")
            vram_path = self.main_window.extraction_panel.get_vram_path()
            logger.debug(f"VRAM path: {vram_path}")

            if not vram_path:
                logger.warning("VRAM path is empty or None")
                self.main_window.status_bar.showMessage("VRAM path not available")
                return

            # Use PreviewGenerator service for unified preview generation
            logger.debug("Using PreviewGenerator service for preview generation")

            # Create preview request
            preview_request = create_vram_preview_request(
                vram_path=vram_path,
                offset=offset,
                sprite_name=f"vram_0x{offset:06X}",
                size=(self.main_window.sprite_preview.width(), self.main_window.sprite_preview.height())
            )

            # Generate preview with progress tracking
            def progress_callback(percent: int, message: str) -> None:
                self.main_window.status_bar.showMessage(f"{message} ({percent}%)")

            result = self.preview_generator.generate_preview(preview_request, progress_callback)

            if result is None:
                logger.error("Preview generation failed")
                self.main_window.status_bar.showMessage("Preview generation failed")
                return

            logger.debug(f"Generated preview with {result.tile_count} tiles, cached: {result.cached}")
            pixmap = result.pixmap
            num_tiles = result.tile_count
            img = result.pil_image

            # Update preview without resetting view (for real-time slider updates)
            logger.debug("Updating sprite preview widget")
            self.main_window.sprite_preview.update_preview(pixmap, num_tiles)

            info_text = f"Tiles: {num_tiles} (Offset: 0x{offset:04X})"
            logger.debug(f"Setting preview info text: {info_text}")
            self.main_window.preview_coordinator.update_preview_info(info_text)

            # Also update the grayscale image for palette application
            logger.debug("Setting grayscale image in sprite preview")
            self.main_window.sprite_preview.set_grayscale_image(img)

            logger.debug("Preview update completed successfully")

        except Exception as e:
            error_msg = f"Preview update failed: {e!s}"
            logger.exception("Error in preview update with offset 0x%04X", offset)

            # Try to show error in status bar
            try:
                self.main_window.status_bar.showMessage(error_msg)
            except Exception:
                logger.exception("Failed to show error in status bar")

            # Try to clear preview on error to prevent showing stale data
            try:
                logger.debug("Attempting to clear preview due to error")
                self.main_window.sprite_preview.clear_preview()
                self.main_window.preview_coordinator.update_preview_info("Preview update failed")
            except Exception:
                logger.exception("Failed to clear preview on error")

    def open_in_editor(self, sprite_file: str) -> None:
        """Open the extracted sprites in the pixel editor"""
        # Get the directory where this spritepal package is located
        spritepal_dir = Path(__file__).parent.parent
        exhal_dir = spritepal_dir.parent

        # Look for pixel editor launcher using absolute paths
        launcher_paths = [
            spritepal_dir / "launch_pixel_editor.py",
            spritepal_dir / "pixel_editor" / "launch_pixel_editor.py",
            exhal_dir / "launch_pixel_editor.py",
            exhal_dir / "pixel_editor" / "launch_pixel_editor.py",
        ]

        launcher_path = None
        for path in launcher_paths:
            if path.exists():
                launcher_path = path
                break

        if launcher_path:
            # Validate sprite file before launching
            image_result = FileValidator.validate_image_file(sprite_file)
            if not image_result.is_valid:
                self.main_window.status_bar.showMessage(
                    f"Invalid sprite file: {image_result.error_message}"
                )
                return

            # Ensure launcher path is absolute and exists
            launcher_path = launcher_path.resolve()
            if not launcher_path.exists():
                self.main_window.status_bar.showMessage(
                    "Pixel editor launcher not found"
                )
                return

            # Launch pixel editor with the sprite file
            try:
                # Use absolute paths for safety
                sprite_file_abs = Path(sprite_file).resolve()
                _ = subprocess.Popen([sys.executable, str(launcher_path), str(sprite_file_abs)])
                self.main_window.status_bar.showMessage(
                    f"Opened {sprite_file_abs.name} in pixel editor"
                )
            except Exception as e:
                self.main_window.status_bar.showMessage(
                    f"Failed to open pixel editor: {e}"
                )
        else:
            self.main_window.status_bar.showMessage("Pixel editor not found")

    def open_row_arrangement(self, sprite_file: str) -> None:
        """Open the row arrangement dialog"""
        # Validate sprite file exists and is valid
        sprite_result = FileValidator.validate_file_existence(sprite_file, "Sprite file")
        if not sprite_result.is_valid:
            self.main_window.status_bar.showMessage(sprite_result.error_message or "Sprite file not found")
            return

        try:
            # Try to get tiles_per_row from sprite preview or use default
            tiles_per_row = self._get_tiles_per_row_from_sprite(sprite_file)

            # Open row arrangement dialog
            # Use main_window as parent only if it's a QWidget (for test compatibility)
            parent = self.main_window if isinstance(self.main_window, QWidget) else None
            dialog = RowArrangementDialog(sprite_file, tiles_per_row, parent)

            # Pass palette data from the main window's sprite preview if available
            if (
                hasattr(self.main_window, "sprite_preview")
                and self.main_window.sprite_preview
            ) and hasattr(self.main_window.sprite_preview, "get_palettes"):
                try:
                    palettes = self.main_window.sprite_preview.get_palettes()
                    if palettes:
                        dialog.set_palettes(palettes)
                except Exception as e:
                    # Log palette loading error but continue with dialog
                    logger.warning(f"Failed to load palette data for dialog: {e}")
                        # Dialog can still function without palette data

            if dialog.exec():
                # Get the arranged sprite path
                arranged_path = dialog.get_arranged_path()

                if arranged_path and Path(arranged_path).exists():
                    # Open the arranged sprite in the pixel editor
                    self.open_in_editor(arranged_path)
                    self.main_window.status_bar.showMessage(
                        "Opened arranged sprites in pixel editor"
                    )
                else:
                    self.main_window.status_bar.showMessage("Row arrangement cancelled")
        except Exception as e:
            self.error_handler.handle_exception(e, "Failed to open row arrangement dialog")

    def open_grid_arrangement(self, sprite_file: str) -> None:
        """Open the grid arrangement dialog"""
        # Validate sprite file exists and is valid
        sprite_result = FileValidator.validate_file_existence(sprite_file, "Sprite file")
        if not sprite_result.is_valid:
            self.main_window.status_bar.showMessage(sprite_result.error_message or "Sprite file not found")
            return

        # Try to get tiles_per_row from sprite preview or use default
        tiles_per_row = self._get_tiles_per_row_from_sprite(sprite_file)

        # Open grid arrangement dialog
        dialog = GridArrangementDialog(sprite_file, tiles_per_row, self.main_window)

        # Pass palette data from the main window's sprite preview if available
        if (
            hasattr(self.main_window, "sprite_preview")
            and self.main_window.sprite_preview
        ) and hasattr(self.main_window.sprite_preview, "get_palettes"):
            try:
                palettes = self.main_window.sprite_preview.get_palettes()
                if palettes:
                    dialog.set_palettes(palettes)
            except Exception as e:
                # Log palette loading error but continue with dialog
                logger.warning(f"Failed to load palette data for dialog: {e}")
                    # Dialog can still function without palette data

        if dialog.exec():
            # Get the arranged sprite path
            arranged_path = dialog.get_arranged_path()

            if arranged_path and Path(arranged_path).exists():
                # Open the arranged sprite in the pixel editor
                self.open_in_editor(arranged_path)
                self.main_window.status_bar.showMessage(
                    "Opened grid-arranged sprites in pixel editor"
                )
            else:
                self.main_window.status_bar.showMessage("Grid arrangement cancelled")

    def _get_tiles_per_row_from_sprite(self, sprite_file: str) -> int:
        """Determine tiles per row from sprite file or main window state

        Args:
            sprite_file: Path to sprite file

        Returns:
            Number of tiles per row
        """
        # Try to get from main window's sprite preview first
        if (
            hasattr(self.main_window, "sprite_preview")
            and self.main_window.sprite_preview
        ):
            try:
                _, tiles_per_row = self.main_window.sprite_preview.get_tile_info()
                if tiles_per_row > 0:
                    return tiles_per_row
            except (AttributeError, TypeError):
                pass

        # Fallback: try to calculate from sprite dimensions
        try:
            with Image.open(sprite_file) as img:
                # Calculate tiles per row based on sprite width
                # Assume 8x8 pixel tiles (TILE_WIDTH)
                calculated_tiles_per_row = img.width // TILE_WIDTH
                if calculated_tiles_per_row > 0:
                    return min(calculated_tiles_per_row, DEFAULT_TILES_PER_ROW)
        except Exception:
            pass

        # Ultimate fallback
        return DEFAULT_TILES_PER_ROW

    def start_injection(self) -> None:
        """Start the injection process using InjectionManager"""
        # Get sprite path and metadata path
        output_base = self.main_window.get_output_path()
        if not output_base:
            self.main_window.status_bar.showMessage("No extraction to inject")
            return

        sprite_path = f"{output_base}.png"
        metadata_path = f"{output_base}.metadata.json"

        # Validate sprite file exists before creating dialog
        sprite_result = FileValidator.validate_file_existence(sprite_path, "Sprite file")
        if not sprite_result.is_valid:
            self.main_window.status_bar.showMessage(sprite_result.error_message or f"Sprite file not found: {sprite_path}")
            return

        # Get smart input VRAM suggestion using injection manager
        suggested_input_vram = self.injection_manager.get_smart_vram_suggestion(
            sprite_path, metadata_path if Path(metadata_path).exists() else ""
        )

        # Show injection dialog
        # Use main_window as parent only if it's a QWidget (for test compatibility)
        parent = self.main_window if isinstance(self.main_window, QWidget) else None
        dialog = InjectionDialog(
            parent,
            sprite_path=sprite_path,
            metadata_path=metadata_path if Path(metadata_path).exists() else "",
            input_vram=suggested_input_vram,
        )

        if dialog.exec():
            params = dialog.get_parameters()
            if params:
                # Store dialog and parameters in session for saving on success
                self.session_manager.set("workflow", "current_injection_dialog", dialog)
                self.session_manager.set("workflow", "current_injection_params", params)

                # Start injection using manager
                success = self.injection_manager.start_injection(params)
                if not success:
                    self.main_window.status_bar.showMessage("Failed to start injection")

    def _on_injection_progress(self, message: str) -> None:
        """Handle injection progress updates"""
        self.main_window.status_bar.showMessage(message)

    def _on_injection_finished(self, success: bool, message: str) -> None:
        """Handle injection completion"""
        if success:
            self.main_window.status_bar.showMessage(f"Injection successful: {message}")

            # Save injection parameters for future use if it was a ROM injection
            current_injection_params = self.session_manager.get("workflow", "current_injection_params")
            current_injection_dialog = self.session_manager.get("workflow", "current_injection_dialog")

            if (
                current_injection_params
                and current_injection_params.get("mode") == "rom"
                and current_injection_dialog
                and hasattr(
                    current_injection_dialog, "save_rom_injection_parameters"
                )
            ):
                try:
                    current_injection_dialog.save_rom_injection_parameters()
                except Exception as e:
                    # Don't fail the injection if saving parameters fails
                    logger.warning(f"Could not save ROM injection parameters: {e}")
        else:
            self.main_window.status_bar.showMessage(f"Injection failed: {message}")

        # Clean up
        self.session_manager.set("workflow", "current_injection_dialog", None)
        self.session_manager.set("workflow", "current_injection_params", None)

    def _on_cache_operation_started(self, operation: str, cache_type: str) -> None:
        """Handle cache operation started notification"""
        settings_manager = get_settings_manager()

        # Only show if indicators are enabled
        if settings_manager.get("cache", "show_indicators", True):
            # Show cache operation badge
            badge_text = f"{operation} {cache_type.replace('_', ' ')}"
            self.main_window.show_cache_operation_badge(badge_text)

    def _on_cache_hit(self, cache_type: str, time_saved: float) -> None:
        """Handle cache hit notification"""
        settings_manager = get_settings_manager()

        # Hide cache operation badge since operation is complete
        self.main_window.hide_cache_operation_badge()

        # Only show if indicators are enabled
        if settings_manager.get("cache", "show_indicators", True):
            # Update status bar with cache hit info
            message = f"Loaded {cache_type.replace('_', ' ')} from cache (saved {time_saved:.1f}s)"
            self.main_window.status_bar.showMessage(message, 5000)

            # Update cache status indicator through status bar manager
            if hasattr(self.main_window.status_bar_manager, "update_cache_status"):
                self.main_window.status_bar_manager.update_cache_status()

    def _on_cache_miss(self, cache_type: str) -> None:
        """Handle cache miss notification"""
        # Cache misses are normal - only log them, don't show in UI
        logger.debug(f"Cache miss for {cache_type}")

    def _on_cache_saved(self, cache_type: str, count: int) -> None:
        """Handle cache saved notification"""
        settings_manager = get_settings_manager()

        # Hide cache operation badge since operation is complete
        self.main_window.hide_cache_operation_badge()

        # Only show if indicators are enabled
        if settings_manager.get("cache", "show_indicators", True):
            # Update status bar with cache save info
            message = f"ðŸ’¾ Saved {count} {cache_type.replace('_', ' ')} to cache"
            self.main_window.status_bar.showMessage(message, 5000)
            # Update cache status widget if method exists
            if hasattr(self.main_window, "update_cache_status"):
                self.main_window.update_cache_status()  # type: ignore[attr-defined]
            # Refresh ROM file widget cache display
            if hasattr(self.main_window, "rom_extraction_panel") and hasattr(self.main_window.rom_extraction_panel, "rom_file_widget"):
                self.main_window.rom_extraction_panel.rom_file_widget.refresh_cache_status()

    def start_rom_extraction(self, params: dict[str, Any]) -> None:
        """Start ROM sprite extraction process"""
        # Convert validated params dict to ROMExtractionParams TypedDict
        rom_extraction_params: ROMExtractionParams = {
            "rom_path": params["rom_path"],
            "sprite_offset": params["sprite_offset"],
            "sprite_name": params["sprite_name"],
            "output_base": params["output_base"],
            "cgram_path": params.get("cgram_path"),
        }
        # Create and start ROM extraction worker
        self.rom_worker = ROMExtractionWorker(rom_extraction_params)
        _ = self.rom_worker.progress.connect(self._on_rom_progress)
        _ = self.rom_worker.extraction_finished.connect(self._on_rom_extraction_finished)
        _ = self.rom_worker.error.connect(self._on_rom_extraction_error)
        self.rom_worker.start()

    def _on_rom_progress(self, percent: int, message: str) -> None:
        """Handle ROM extraction progress"""
        self.main_window.status_bar.showMessage(message)

    def _on_rom_extraction_finished(self, extracted_files: list[str]) -> None:
        """Handle ROM extraction completion"""
        self.main_window.extraction_complete(extracted_files)
        self._cleanup_rom_worker()

    def _on_rom_extraction_error(self, error_message: str) -> None:
        """Handle ROM extraction error"""
        self.main_window.extraction_failed(error_message)
        self._cleanup_rom_worker()

    def _cleanup_rom_worker(self) -> None:
        """Safely cleanup ROM worker thread"""
        WorkerManager.cleanup_worker(self.rom_worker, timeout=3000)
        self.rom_worker = None

